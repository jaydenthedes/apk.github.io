var _TOPBAR_HEIGHT = 32, _ALLOWED_VALUES_MAP = {
  formFactor: ["maximized", "phone", "tablet"],
  fpsLimit: [1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60],
  ndkAbi: ["armeabi", "armeabi-v7a"],
  orientation: ["landscape", "portrait"],
  resize: ["disabled", "scale"],
  stderrLog: "DVIWEFS".split("")
}, _common = {cachedRuntimeManifestPromise: null}, _STRING_DELIMITER = "\u0001", _TARGET_ANDROID_DP = {
  phone: {
    "long": 640,
    "short": 360
  }, tablet: {"long": 1280, "short": 800}
};
function getTimeZone() {
  var a = -(new Date).getTimezoneOffset(), c = 0 <= a ? "+" : "-", a = Math.abs(a), b = String(Math.floor(a / 60)), a = String(a % 60);
  1 == b.length && (b = "0" + b);
  1 == a.length && (a = "0" + a);
  return "GMT" + c + b + ":" + a
}
function getLocale() {
  var a = window.navigator.language;
  "es-419" == a && (a = "es");
  a = a.split("-");
  return {language: a[0], country: a[1]}
}
function getCurrentZoom() {
  if (!document.body)return 1;
  var a = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  a.style.cssText = "position: absolute;visibility: hidden;";
  document.body.appendChild(a);
  var c = a.currentScale;
  document.body.removeChild(a);
  return c
}
var arcMetadata;
(function () {
  function a() {
    this.defaults_ = {
      allowEmptyActivityStack: !1,
      apkList: [],
      disableAutoBackButton: !1,
      enableAccessibility: !1,
      enableAdb: !1,
      enableArcStrace: !1,
      enableCompositor: !1,
      enableExternalDirectory: !1,
      enableGlErrorCheck: !1,
      disableGlFixedAttribs: !1,
      enableSynthesizeTouchEventsOnWheel: !0,
      formFactor: "phone",
      fpsLimit: 60,
      isSlowDebugRun: !1,
      jdbPort: 0,
      jsFullTestList: [],
      jsTestFilter: "*",
      logLoadProgress: !1,
      minimumLaunchDelay: 0,
      name: "",
      ndkAbi: "",
      orientation: "portrait",
      packageName: "org.chromium.arc",
      javaTraceStartup: 0,
      resize: "disabled",
      shell: [],
      stderrLog: "S",
      useGoogleContactsSyncAdapter: !1,
      usePlayServices: [],
      sleepOnBlur: !0
    };
    this.data_ = {};
    this.computedValues_ = {};
    if (chrome.runtime && chrome.runtime.getManifest) {
      var a = chrome.runtime.getManifest();
      this.data_ = a.arc_metadata || {};
      this.validateData_();
      this.computeValues_(a)
    }
  }

  a.prototype.get = function () {
    var a = {}, b;
    for (b in this.defaults_)this.defaults_.hasOwnProperty(b) && (this.data_.hasOwnProperty(b) ? a[b] = this.data_[b] : a[b] = this.defaults_[b]);
    return this.addComputedValues_(a)
  };
  a.prototype.getValue = function (a) {
    if (this.data_.hasOwnProperty(a))return this.data_[a];
    if (this.computedValues_.hasOwnProperty(a))return this.computedValues_[a];
    if (this.defaults_.hasOwnProperty(a))return this.defaults_[a];
    throw"unknown arc_metadata param: " + a;
  };
  a.prototype.validateData_ = function () {
    for (var a in this.data_)if (this.data_.hasOwnProperty(a) && (this.defaults_.hasOwnProperty(a) ? typeof this.data_[a] !== typeof this.defaults_[a] && (console.error('Type mismatch of "' + a + '" in ARC metadata'), console.group(),
        console.error("Default type: " + typeof this.defaults_[a]), console.error("Current type: " + typeof this.data_[a]), console.groupEnd()) : console.error('Unknown property "' + a + '" in ARC metadata')), a in _ALLOWED_VALUES_MAP) {
      var b = this.data_[a], d = _ALLOWED_VALUES_MAP[a];
      -1 == d.indexOf(b) && (console.group(), console.error("Invalid value of " + a + ": " + b), console.error("It must be one of: " + d.join(", ")), console.groupEnd())
    }
  };
  a.prototype.getAndroidDensityDpi_ = function (a, b) {
    var d = [120, 160, 213, 240, 320, 400, 480, 640], e =
      160 * b;
    "phone" != a && (e *= 0.75);
    var f = d.map(function (a) {
      return Math.abs(a - e)
    }), f = f.indexOf(Math.min.apply(Math, f));
    return d[f]
  };
  a.prototype.computeWindowSizeInChromeDips_ = function (a, b) {
    var d = this.getAndroidDensityDpi_(a, b);
    shortChromeDip = Math.ceil(_TARGET_ANDROID_DP[a].short * (d / 160) / b);
    longChromeDip = Math.ceil(_TARGET_ANDROID_DP[a].long * (d / 160) / b);
    return {"short": shortChromeDip, "long": longChromeDip, androidDensityDpi: d}
  };
  a.prototype.computeValues_ = function (a) {
    var b = window.devicePixelRatio / getCurrentZoom(),
      d = this.getValue("formFactor"), e;
    "maximized" == d ? (a = screen.availWidth, e = screen.availHeight - _TOPBAR_HEIGHT, b = this.getAndroidDensityDpi_(d, b)) : (b = this.computeWindowSizeInChromeDips_(d, b), "landscape" == this.getValue("orientation") ? (a = b.long, e = b.short) : (a = b.short, e = b.long), b = b.androidDensityDpi);
    this.computedValues_.width = a;
    this.computedValues_.height = e;
    this.computedValues_.androidDensityDpi = b;
    b = !1;
    a <= screen.availHeight - _TOPBAR_HEIGHT && e <= screen.availWidth && (b = !0);
    this.computedValues_.canRotate = b
  };
  a.prototype.addComputedValues_ =
    function (a) {
      for (var b in this.computedValues_)this.computedValues_.hasOwnProperty(b) && (a[b] = this.computedValues_[b]);
      return a
    };
  arcMetadata = new a
})();
function getRuntimeID() {
  return chrome.runtime.getManifest()["import"][0].id
}
function getRuntimeManifestURL() {
  var a = getRuntimeID();
  return chrome.runtime.getURL("/_modules/" + a + "/manifest.json")
}
function requestRuntimeManifest() {
  if (null !== _common.cachedRuntimeManifestPromise)return _common.cachedRuntimeManifestPromise;
  var a = getRuntimeManifestURL();
  _common.cachedRuntimeManifestPromise = PromiseWrap.xmlHttpRequest("GET", a).then(JSON.parse);
  return _common.cachedRuntimeManifestPromise
}
function getManifestItem(a, c, b) {
  return a.hasOwnProperty(c) ? a[c] : b
}
function getBuildTagFromManifest(a) {
  return getManifestItem(a, "arc_build_tag", "unknown")
}
function isManifestCWSInstalled(a) {
  a = getManifestItem(a, "update_url", "");
  var c = document.createElement("a");
  c.href = a;
  return "clients2.google.com" == c.host && "/service/update2/crx" == c.pathname ? !0 : !1
}
function isAppCwsInstalled() {
  var a = chrome.runtime.getManifest();
  return isManifestCWSInstalled(a)
}
function getRuntimeCwsInstalled() {
  return new Promise(function (a, c) {
    requestRuntimeManifest().then(function (b) {
      a(isManifestCWSInstalled(b))
    })
  })
}
function shouldSendCrashReports() {
  return new Promise(function (a, c) {
    requestRuntimeManifest().then(function (b) {
      null != getBuildTagFromManifest(b).match(/^arc-runtime-\d+\.\d+\.\d+\.\d+$/) ? a(!0) : a(!1)
    })
  })
}
function applyPromise(a, c) {
  return Promise.all(a).then(function (a) {
    return c.apply(null, a)
  })
}
function PromiseBridge(a) {
  this.fullfilled = !1;
  this.fullfilledValue = null;
  this.rejected = !1;
  this.rejectedValue = null;
  this.resolveCallbacks = [];
  this.rejectCallbacks = [];
  var c = this;
  a.then(function (a) {
    c.fullfilled = !0;
    c.fullfilledValue = a;
    var d = c.resolveCallbacks;
    c.resolveCallbacks = [];
    c.rejectCallbacks = [];
    for (var e = 0; e < d.length; ++e)d[e](a)
  }, function (a) {
    c.rejected = !0;
    c.rejectedValue = a;
    var d = c.rejectCallbacks;
    c.resolveCallbacks = [];
    c.rejectCallbacks = [];
    for (var e = 0; e < d.length; ++e)d[e](a)
  })
}
PromiseBridge.createPromise = function (a) {
  return new Promise(function (c, b) {
    a.fullfilled ? c(a.fullfilledValue) : a.rejected ? b(a.rejectedValue) : (a.resolveCallbacks.push(c), a.rejectCallbacks.push(b))
  })
};
var childPlugins = [];
function ChildPlugin(a, c, b, d, e) {
  this.active = !0;
  this.args_ = c.args;
  this.backgroundPage_ = null;
  this.command_ = c.plugin;
  this.container_ = a;
  this.currentWorkingDirectory_ = c.currentworkingdirectory;
  this.envs_ = c.envs;
  this.handleExitMessage_ = b;
  this.handleStderrMessage_ = e;
  this.handleStdoutMessage_ = d;
  this.loaded_ = !1;
  this.plugin_ = null;
  this.preopened_fd_args_ = c.preopened_fd_args;
  this.preopened_fd_names_ = c.preopened_fd_names;
  this.requestId_ = c.requestId;
  this.requester_ = c.requester;
  this.timeoutId_ = null;
  this.timeout_ =
    2;
  this.create_()
}
ChildPlugin.prototype.create_ = function () {
  var a = arcMetadata.get();
  this.plugin_ = document.createElement("embed");
  var c = getRuntimeID();
  this.plugin_.setAttribute("src", "/_modules/" + c + "/arc.nmf");
  this.plugin_.setAttribute("type", "application/x-nacl");
  this.plugin_.setAttribute("plugintype", this.command_);
  this.currentWorkingDirectory_ && this.plugin_.setAttribute("current_working_directory", this.currentWorkingDirectory_);
  this.plugin_.setAttribute("args", this.args_.join(_STRING_DELIMITER));
  this.envs_ && this.plugin_.setAttribute("envs",
    this.envs_.join(_STRING_DELIMITER));
  this.preopened_fd_args_ && this.preopened_fd_names_ && (this.plugin_.setAttribute("preopened_fd_args", this.preopened_fd_args_.join(_STRING_DELIMITER)), this.plugin_.setAttribute("preopened_fd_names", this.preopened_fd_names_.join(_STRING_DELIMITER)));
  this.plugin_.setAttribute("request_id", this.requestId_);
  this.plugin_.setAttribute("requester", this.requester_);
  this.plugin_.setAttribute("width", 0);
  this.plugin_.setAttribute("height", 0);
  this.plugin_.setAttribute("packagename",
    a.packageName);
  this.plugin_.setAttribute("stderrlog", a.stderrLog);
  this.plugin_.setAttribute("enablearcstrace", a.enableArcStrace);
  this.plugin_.setAttribute("timezone", getTimeZone());
  a = getLocale();
  this.plugin_.setAttribute("language", a.language);
  a.country && this.plugin_.setAttribute("country", a.country);
  (this.handleStderrMessage_ || this.handleStdoutMessage_) && this.plugin_.setAttribute("enable_stdio_bridge", !0);
  var b = this;
  getRuntimeCwsInstalled().then(function (a) {
    a || b.plugin_.setAttribute("enable_ndk_executable",
      !0);
    console.time("ChildPlugin " + b.requester_ + ":" + b.requestId_ + ":" + b.args_[0] + "(" + b.command_ + ") Run");
    b.container_.appendChild(b.plugin_);
    b.plugin_.addEventListener("message", b.handleMessageEvent_.bind(b), !1);
    b.plugin_.addEventListener("crash", function (a) {
      b.postExitMessage_(b.createExitMessage_(-1), "Plugin process crashed")
    }, !1);
    b.timeoutId_ = setTimeout(function () {
      b.timeoutId_ = null;
      if (!b.loaded_) {
        var a = b.container_;
        b.remove("timeout to spawn ChildPlugin process: " + b.args_[0] + "(" + b.command_ + "), " + b.args_.join(" "));
        32 <= b.timeout_ ? (console.error("give up to spawn ChildPlugin process."), b.postExitMessage_(b.createExitMessage_(-1))) : (b.timeout_ *= 2, console.log("retry to spawn with timeout " + b.timeout_ + "sec."), b.active = !0, b.container_ = a, b.create_())
      }
    }, 1E3 * b.timeout_)
  });
  this.backgroundPage_ = window.arc ? window.arc.backgroundPage : window
};
ChildPlugin.prototype.handleMessageEvent_ = function (a) {
  if (this.active)if (a = a.data, a.constructor == ArrayBuffer)this.backgroundPage_.crashReporter.reportCrash("minidump on " + this.command_, a); else {
    if ("jsPlugin" == a.namespace) {
      if ("loadResult" == a.command) {
        a.data.result ? (a = this.command_, 0 < this.args_.length && (a += "/" + this.args_[0]), console.log("the child process has been loaded: " + a), this.loaded_ = !0) : this.remove("Cannot load plugin process");
        return
      }
      if ("crashLogMessage" == a.command)return
    }
    "jsChildplugin" != a.namespace ?
      this.remove('Received invalid namespace message. Namespace: "' + a.namespace + '", Command: "' + a.command + '"') : "spawn" == a.command ? ChildPlugin.handleChildPluginMessage(a, this.plugin_.postMessage.bind(this.plugin_), this.handleStdoutMessage_, this.handleStderrMessage_) : "stdout" == a.command ? (a.namespace = this.requester_, this.handleStdoutMessage_ && this.handleStdoutMessage_(a)) : "stderr" == a.command ? (a.namespace = this.requester_, this.handleStderrMessage_ && this.handleStderrMessage_(a)) : "exit" == a.command ? (a.namespace =
      this.requester_, this.postExitMessage_(a)) : this.remove("Received unknown childplugin command: " + a.command)
  }
};
ChildPlugin.prototype.postExitMessage_ = function (a, c) {
  this.remove(c) && this.handleExitMessage_(a)
};
ChildPlugin.prototype.createExitMessage_ = function (a) {
  return {namespace: this.requester_, command: "exit", data: {requestId: this.requestId_, result: a}}
};
ChildPlugin.prototype.remove = function (a) {
  if (!this.active)return !1;
  this.active = !1;
  this.timeoutId_ && (clearTimeout(this.timeoutId_), this.timeoutId_ = null);
  console.timeEnd("ChildPlugin " + this.requester_ + ":" + this.requestId_ + ":" + this.args_[0] + "(" + this.command_ + ") Run");
  a && console.log(a);
  this.container_.removeChild(this.plugin_);
  this.plugin_ = this.container_ = null;
  childPlugins = childPlugins.filter(function (a) {
    a != this
  });
  return !0
};
ChildPlugin.handleChildPluginMessage = function (a, c, b, d) {
  "spawn" == a.command ? childPlugins.push(new ChildPlugin(document.getElementById("appdiv"), a.data, c, b, d)) : (console.log("Received unknown childplugin message: "), console.log(a))
};
var _CRASH_REPORT_SETTING_UNKNOWN = -1, _CRASH_REPORT_SETTING_DISABLED = 0, _CRASH_REPORT_SETTING_ENABLED = 1, _CRASH_REPORT_STORAGE_KEY = "crashReports", _CRASH_REPORT_STORAGE_BOOT_DELAY = 1E4, _CRASH_REPORT_MAX_AGE = 432E6;
function CrashReporter() {
  this.crashReportingEnabled_ = _CRASH_REPORT_SETTING_UNKNOWN;
  this.didReadFromStorage_ = !1;
  this.logFinishReportingCrash = !0;
  window.main && window.main.underJavascriptTestRunner && (this.logFinishReportingCrash = !1);
  this.pendingCrashReports_ = [];
  this.startTime_ = new Date
}
function showCrashInfo_(a, c) {
  a && console.log(a);
  c && console.log("crash id: " + c)
}
function crashIsTooOld_(a) {
  return !a.hasOwnProperty("crash_time") || new Date - a.crash_time > _CRASH_REPORT_MAX_AGE ? !0 : !1
}
CrashReporter.prototype.sendCrashReport_ = function (a) {
  if (this.crashReportingEnabled_ == _CRASH_REPORT_SETTING_UNKNOWN)this.pendingCrashReports_.push(a); else if (this.crashReportingEnabled_ == _CRASH_REPORT_SETTING_DISABLED)showCrashInfo_("Crash reporting not enabled in Chrome.  Please enable it."); else if (!crashIsTooOld_(a)) {
    var c = new FormData, b;
    for (b in a)0 === b.indexOf("upload_file_") ? c.append(b, new Blob([a[b]])) : c.append(b, a[b]);
    var d = new XMLHttpRequest;
    d.open("POST", "https://clients2.google.com/cr/report",
      !0);
    d.onreadystatechange = function () {
      4 == d.readyState && (200 == d.status ? showCrashInfo_("Successfully uploaded crash report", d.responseText) : showCrashInfo_("Failed to report crash, status: " + d.status))
    };
    console.log("Attempting to report crash...");
    d.send(c)
  }
};
CrashReporter.prototype.sendPendingCrashReports_ = function () {
  if (this.crashReportingEnabled_ != _CRASH_REPORT_SETTING_UNKNOWN) {
    for (var a = 0; a < this.pendingCrashReports_.length; a++)this.sendCrashReport_(this.pendingCrashReports_[a]);
    this.pendingCrashReports_ = []
  }
};
CrashReporter.prototype.setCrashReportingEnabled = function (a) {
  this.crashReportingEnabled_ = a;
  this.sendPendingCrashReports_()
};
function printMiniDump_(a, c) {
  if (null != a) {
    for (var b = "", d = new Uint8Array(a), e = 0; e < d.byteLength; e++)b += String.fromCharCode(d[e]);
    b = window.btoa(b);
    console.error("@@@Minidump generated@@@minidump_" + c + "@@@" + b + "@@@")
  }
}
CrashReporter.prototype.reportCrash = function (a, c, b) {
  var d = this, e = {}, f;
  console.log("Received a crash");
  return requestRuntimeManifest().then(function (h) {
    var g = getBuildTagFromManifest(h);
    f = g.replace(/^arc-runtime-/, "");
    e = {
      prod: "ARC",
      arc_app_name: arcMetadata.getValue("name"),
      ptime: new Date - d.startTime_,
      crash_time: new Date,
      ver: f,
      arc_build_tag: g,
      message: a,
      chrome_version: navigator.appVersion.match(/Chrome\/(\S*)/)[1],
      app_id: chrome.runtime.id,
      app_version: chrome.runtime.getManifest().version || "",
      app_package_name: arcMetadata.getValue("packageName"),
      runtime_name: getManifestItem(h, "name", "unknown"),
      runtime_update_url: getManifestItem(h, "update_url", "unknown")
    };
    if (b)for (var k in b)e[k] = b[k];
    (h = navigator.appVersion.match(/CrOS\s(\S*)\s([^)]*)/)) && (e.cros_version = h[2]);
    null != c && (e.upload_file_minidump = c);
    return PromiseWrap.getPlatformInfo()
  }).then(function (a) {
    e.arch = a.arch;
    e.nacl_arch = a.nacl_arch;
    e.os = a.os;
    return shouldSendCrashReports()
  }).then(function (a) {
    for (var b in e)"upload_file_minidump" != b && console.log(b + ": " + e[b]);
    a ? d.sendCrashReport_(e) :
      (showCrashInfo_("Not installed from CWS, not sending crash report."), printMiniDump_(c, f));
    d.logFinishReportingCrash && console.log("FINISHED REPORTING CRASH")
  })
};
CrashReporter.prototype.readFromStorage_ = function (a) {
  chrome.storage.local.get(_CRASH_REPORT_STORAGE_KEY, function (c) {
    c = c[_CRASH_REPORT_STORAGE_KEY] ? JSON.parse(c[_CRASH_REPORT_STORAGE_KEY]) : [];
    for (var b = 0; b < c.length; b++)this.pendingCrashReports_.push(c[b]);
    chrome.storage.local.remove(_CRASH_REPORT_STORAGE_KEY);
    a && a()
  }.bind(this))
};
CrashReporter.prototype.writeToStorage_ = function (a) {
  var c = {};
  c[_CRASH_REPORT_STORAGE_KEY] = JSON.stringify(this.pendingCrashReports_);
  chrome.storage.local.set(c, function () {
    chrome.runtime.lastError && (console.error("Unable to set storage for pending crash reports"), console.error("Reason: " + runtime.lastError));
    a && a()
  })
};
CrashReporter.prototype.init = function (a) {
  this.startTime_ = new Date;
  setTimeout(function () {
    this.readFromStorage_(function () {
      this.sendPendingCrashReports_();
      this.didReadFromStorage_ = !0;
      a && a()
    }.bind(this))
  }.bind(this), _CRASH_REPORT_STORAGE_BOOT_DELAY)
};
CrashReporter.prototype.shutDown = function (a) {
  this.crashReportingEnabled_ == _CRASH_REPORT_SETTING_UNKNOWN && 0 < this.pendingCrashReports_.length && (this.didReadFromStorage_ ? this.writeToStorage_(a) : this.readFromStorage_(function () {
    this.writeToStorage_(a)
  }.bind(this)))
};
var crashReporter = new CrashReporter;
function gcmServicesEnabled() {
  var a = arcMetadata.getValue("usePlayServices");
  return a && 0 <= a.indexOf("gcm")
}
function GcmManager() {
  this.gcmInitialized_ = !1
}
GcmManager.prototype.handleGcmRequest = function (a, c) {
  gcmServicesEnabled() && void 0 !== chrome.gcm ? "init" == a.command ? this.gcmInitialized_ = !0 : "register" == a.command ? this.register_(a.data.senderIds, c) : "unregister" == a.command ? this.unregister_(c) : "send" == a.command ? this.send_(a) : console.warn("Received unknown GCM message: " + a) : console.warn("Received GCM request while not supported")
};
GcmManager.prototype.getPlugin_ = function () {
  return appWindow && appWindow.contentWindow ? appWindow.contentWindow.plugin : null
};
GcmManager.prototype.register_ = function (a, c) {
  a ? chrome.gcm.register(a.split(","), function (a) {
    var d = {namespace: "androidGcm", data: {}};
    chrome.runtime.lastError ? (console.log("Failed to register gcm: " + chrome.runtime.lastError.message), d.command = "registerError", d.data.error = this.convertToAndroidError_(chrome.runtime.lastError.message)) : (d.command = "registerSuccess", d.data.registrationId = a);
    c.postMessage(d)
  }.bind(this)) : console.error("No senderIds", a)
};
GcmManager.prototype.unregister_ = function (a) {
  chrome.gcm.unregister(function () {
    var c = {namespace: "androidGcm", data: {}};
    chrome.runtime.lastError ? (console.error("Error happened on unregister: " + chrome.runtime.lastError.message), c.command = "unregisterError", c.data.error = this.convertToAndroidError_(chrome.runtime.lastError.message)) : c.command = "unregisterCallback";
    a.postMessage(c)
  }.bind(this))
};
GcmManager.prototype.send_ = function (a) {
  a = a.data;
  var c = {destinationId: a["google.to"], messageId: a["google.message_id"], timeToLive: a["google.ttl"], data: {}}, b;
  for (b in a)0 != b.indexOf("google") && 0 != b.indexOf("goog.") && (c.data[b] = a[b]);
  chrome.gcm.send(c, function (a) {
    if (chrome.runtime.lastError) {
      var b = this.convertToAndroidError_(chrome.runtime.lastError.message);
      this.onMessageInternal_("sendError", {errorMessage: b, messageId: a})
    }
  }.bind(this))
};
GcmManager.prototype.onMessageInternal_ = function (a, c) {
  var b = {namespace: "androidGcm", command: a, data: {}};
  c && (b.data = c);
  try {
    var d = this.getPlugin_();
    d ? this.gcmInitialized_ ? d.postMessage(b) : console.warn("GCM has not initialized yet") : console.log("Background mode is not yet supported")
  } catch (e) {
    console.error("Error sending the message into plugin: " + e)
  }
};
GcmManager.prototype.convertToAndroidError_ = function (a) {
  var c = {
    "Function was called with invalid parameters.": "INVALID_PARAMETERS",
    "Profile was not signed in.": "ACCOUNT_MISSING",
    "Manifest key was missing.": "INVALID_PARAMETERS",
    "Asynchronous operation is pending.": "SERVICE_NOT_AVAILABLE",
    "Network error occurred.": "SERVICE_NOT_AVAILABLE",
    "Server error occurred.": "SERVICE_NOT_AVAILABLE",
    "Time-to-live exceeded.": "SERVICE_NOT_AVAILABLE",
    "Unknown error occurred.": "SERVICE_NOT_AVAILABLE"
  }[a];
  if (c)return c;
  console.error("chrome.gcm: unexpected error string: " + a);
  return "SERVICE_NOT_AVAILABLE"
};
GcmManager.prototype.onMessage = function (a) {
  this.onMessageInternal_("receive", a.data)
};
GcmManager.prototype.onMessagesDeleted = function () {
  this.onMessageInternal_("deletedMessages")
};
GcmManager.prototype.onSendError = function (a) {
  this.onMessageInternal_("sendError", a)
};
var gcm = null;
gcmServicesEnabled() && chrome.gcm && (gcm = new GcmManager, chrome.gcm.onMessage.addListener(gcm.onMessage.bind(gcm)), chrome.gcm.onMessagesDeleted.addListener(gcm.onMessagesDeleted.bind(gcm)), chrome.gcm.onSendError.addListener(gcm.onSendError.bind(gcm)));
var PromiseWrap = {
  chooseEntry: function (a) {
    return new Promise(function (c, b) {
      chrome.fileSystem.chooseEntry(a, function (a) {
        chrome.runtime.lastError ? b(chrome.runtime.lastError) : a ? c(a) : b(Error("User cancelled"))
      })
    })
  }, isFilesystemRestorable: function (a) {
    return new Promise(function (c, b) {
      chrome.fileSystem.isRestorable(a, function (d) {
        d ? c(a) : b(Error("The filesystem is not restorable."))
      })
    })
  }, restoreFilesystem: function (a) {
    return new Promise(function (c, b) {
      chrome.fileSystem.restoreEntry(a, function (a) {
        a ? c(a) : b(Error(chrome.runtime.lastError.message))
      })
    })
  },
  getAuthToken: function (a) {
    return new Promise(function (c, b) {
      chrome.identity.getAuthToken(a, function (a) {
        chrome.runtime.lastError ? b(Error(chrome.runtime.lastError.message)) : c(a)
      })
    })
  }, getPlatformInfo: function () {
    return new Promise(function (a, c) {
      chrome.runtime.getPlatformInfo(function (b) {
        a(b)
      })
    })
  }, getProfileUserInfo: function () {
    return new Promise(function (a, c) {
      chrome.identity && chrome.identity.getProfileUserInfo ? chrome.identity.getProfileUserInfo(function (b) {
        chrome.runtime.lastError ? c(Error(chrome.runtime.lastError.message)) :
          a(b)
      }) : c(Error("chrome.identity.getProfileUserInfo is unavailable. Please make sure your Chrome is at least M37."))
    })
  }, removeCachedAuthToken: function (a) {
    return new Promise(function (c, b) {
      chrome.identity.removeCachedAuthToken(a, function () {
        chrome.runtime.lastError ? b(Error(chrome.runtime.lastError.message)) : c()
      })
    })
  }, getLocalStorageValue: function (a) {
    return new Promise(function (c, b) {
      chrome.storage.local.get(a, function (d) {
        d.hasOwnProperty(a) ? c(d[a]) : (chrome.runtime.lastError && console.error("Error on reading local storage, continue anyway: " +
        chrome.runtime.lastError.message), b(Error("There is no retained filesystem key.")))
      })
    })
  }, setLocalStorageValue: function (a) {
    return new Promise(function (c, b) {
      chrome.storage.local.set(a, function (a) {
        chrome.runtime.lastError ? b(Error("Cannot save email to local storage: " + chrome.runtime.lastError.message)) : c()
      })
    })
  }, requestFileSystem: function (a) {
    return new Promise(function (c, b) {
      window.webkitRequestFileSystem(a, 1, function (a) {
        c(a)
      }, function (a) {
        b(Error(a))
      })
    })
  }, requestFileSystemRoot: function (a) {
    return PromiseWrap.requestFileSystem(a).then(function (a) {
      return a.root
    })
  },
  xmlHttpRequest: function (a, c, b) {
    void 0 == b && (b = "text");
    return new Promise(function (d, e) {
      var f = new XMLHttpRequest;
      f.open(a, c, !0);
      f.responseType = b;
      f.onreadystatechange = function () {
        try {
          4 == f.readyState && (200 == f.status ? d(f.response) : e(Error(f.response)))
        } catch (a) {
          e(Error(a))
        }
      };
      f.send()
    })
  }, getDirectory: function (a, c, b) {
    return new Promise(function (d, e) {
      a.getDirectory(c, b, function (a) {
        d(a)
      }, function (a) {
        e(Error(a))
      })
    })
  }, getFile: function (a, c, b) {
    return new Promise(function (d, e) {
      a.getFile(c, b, function (a) {
        d(a)
      }, function (a) {
        e(Error(a))
      })
    })
  },
  getMetadata: function (a) {
    return new Promise(function (c, b) {
      a.getMetadata(function (a) {
        c(a)
      }, function (a) {
        b(Error(a))
      })
    })
  }, readEntries: function (a) {
    var c = a.createReader(), b = [];
    return new Promise(function (a, e) {
      var f = function () {
        c.readEntries(function (c) {
          0 === c.length ? a(Array.prototype.concat.apply([], b)) : (b.push(c), f())
        }, function (a) {
          e(Error(a))
        })
      };
      f()
    })
  }, removeEntryRecursively: function (a) {
    return new Promise(function (c, b) {
      a.isDirectory ? a.removeRecursively(function () {
        c()
      }, function (a) {
        b(Error(a))
      }) : a.remove(function () {
          c()
        },
        function (a) {
          b(Error(a))
        })
    })
  }, moveTo: function (a, c, b) {
    return new Promise(function (d, e) {
      a.moveTo(c, b, function (a) {
        d(a)
      }, function (a) {
        e(Error(a))
      })
    })
  }, createWriter: function (a) {
    return new Promise(function (c, b) {
      a.createWriter(function (a) {
        c(a)
      }, function (a) {
        b(Error(a))
      })
    })
  }, truncate: function (a, c) {
    return new Promise(function (b, d) {
      a.readyState === a.WRITING ? d(Error(new DOMError("InvalidStateError"))) : (a.onwrite = function () {
        a.onwrite = null;
        a.onerror = null;
        b(a)
      }, a.onerror = function (b) {
        a.onwrite = null;
        a.onerror = null;
        d(Error(b))
      },
        a.truncate(c))
    })
  }, write: function (a, c) {
    return new Promise(function (b, d) {
      a.readyState === a.WRITING ? d(Error(new DOMError("InvalidStateError"))) : (a.onwrite = function (c) {
        a.onwrite = null;
        a.onerror = null;
        b(a)
      }, a.onerror = function (b) {
        a.onwrite = null;
        a.onerror = null;
        d(Error(b))
      }, a.write(c))
    })
  }, file: function (a) {
    return new Promise(function (c, b) {
      a.file(function (a) {
        c(a)
      }, function (a) {
        b(Error(a))
      })
    })
  }, readBlobAsText: function (a) {
    return new Promise(function (c, b) {
      var d = new FileReader;
      d.onload = function () {
        c(d.result)
      };
      d.onerror =
        function () {
          b(Error(d.error))
        };
      d.readAsText(a)
    })
  }
};
function getParentPath(a) {
  if ("/" === a)return a;
  a = a.replace(/\/+$/, "");
  var c = a.lastIndexOf("/");
  return 0 === c ? "/" : 0 > c ? "" : a.slice(0, c)
}
function joinPath(a, c) {
  return (a + "/" + c).replace(/\/+/g, "/")
}
function createDirectoryMetadata(a) {
  return {fullPath: a, exists: !0, isFile: !1, mtime_ms: "0", size: "4096"}
}
function createMissingEntryMetadata(a) {
  return {fullPath: a, exists: !1}
}
function createDirectories(a, c) {
  function b(c) {
    var g = getParentPath(c);
    if (g === c)return Promise.resolve();
    if (c in h)return h[c];
    g = b(g).then(function () {
      return PromiseWrap.getDirectory(a, c, {create: !0})
    }).then(d, e.bind(null, c));
    h[c] = g;
    f.push(g);
    return g
  }

  function d(a) {
    return createDirectoryMetadata(a.fullPath)
  }

  function e(b) {
    return createMissingEntryMetadata(joinPath(a.fullPath, b))
  }

  for (var f = [], h = {}, g = 0; g < c.length; ++g)b(c[g]);
  return Promise.all(f)
}
function createSystemDirectories() {
  var a = PromiseWrap.requestFileSystemRoot(PERSISTENT), c = arcMetadata.get().packageName, b = ["cache", "data/app", "data/app-lib", "data/dalvik-cache", "data/data/org.chromium.arc/lib", "data/local/tmp", "data/misc/keystore", "data/system/dropbox", "data/system/ifw", "data/system/inputmethod", "data/system/netstats", "data/system/procstats", "data/system/sync", "data/system/usagestats", "data/system/users/0", "data/user", "storage/sdcard", "data/app-lib/arc", "data/app-private", "data/data/" +
  c + "/lib", "data/system/registered_services", "storage/sdcard/Android/data/" + c, "storage/sdcard/Android/data/org.chromium.arc/"], d = b.join("\n");
  return applyPromise([a, ".system_directories_ready", {create: !1}], PromiseWrap.getFile).then(PromiseWrap.file).then(PromiseWrap.readBlobAsText).then(function (a) {
    if (a === d) {
      a = [];
      for (var c = 0; c < b.length; ++c)a.push(createDirectoryMetadata(joinPath("/", b[c])));
      return a
    }
    console.log("The set of system directories is changed. Recreating.");
    return Promise.reject()
  }).catch(function (c) {
    c =
      applyPromise([a, b], createDirectories);
    var f = c.then(function () {
      return applyPromise([a, ".system_directories_ready", {create: !0}], PromiseWrap.getFile)
    }).then(PromiseWrap.createWriter), f = applyPromise([f, 0], PromiseWrap.truncate);
    applyPromise([f, new Blob([d])], PromiseWrap.write).catch(function () {
      console.error("Failed to make marker file for system directory creation.")
    });
    return c
  })
};
var appWindow, appLaunched = !1, dexoptPlugin, pendingUma = [], _ONINSTALL_MAX_DELAY_IN_MINUTES = 4, systemDirectoriesCreated = null;
function addDexoptPlugin_() {
  if (!dexoptPlugin && !appLaunched) {
    var a = arcMetadata.get().apkList, a = {
      requestId: 0,
      requester: "jsInstaller",
      plugin: "so_executable",
      args: ["dexopt", "--preopt", "/vendor/chromium/crx/" + a[a.length - 1], "$auto", "v=r,o=v,m=y,u=n"]
    };
    dexoptPlugin = new ChildPlugin(document.getElementById("childplugindiv"), a, function (a) {
      0 != a.data.result && console.error("Failed to dexopt on installation.");
      dexoptPlugin = null
    }, null, null)
  }
}
function needEmailToLaunch_() {
  var a = chrome.runtime.getManifest().permissions;
  return a && 0 <= a.indexOf("identity.email")
}
function maybeKillDexopt_() {
  var a = !1;
  dexoptPlugin && dexoptPlugin.active && (dexoptPlugin.remove("Dexopt plugin terminated"), a = !0);
  scheduleUma(["bool", "ArcRuntime.DexoptInterrupted", a])
}
function onLaunch(a, c) {
  function b(b) {
    var d = (new Date).getTime(), h = "runtime/gen_index.min.html", g = "", g = getRuntimeID(), h = "/_modules/" + g + "/gen_index.min.html";
    a.hasOwnProperty("windowIdOverride") && (g = a.windowIdOverride);
    appWindow = chrome.app.window.get(g);
    if (null == appWindow || a.forceWindowCreate) {
      console.time("ARC Window Popup");
      maybeKillDexopt_();
      crashReporter.init();
      var k = arcMetadata.getValue("width"), l = arcMetadata.getValue("height") + _TOPBAR_HEIGHT, g = {
        id: g, width: k, height: l, resizable: "disabled" != arcMetadata.getValue("resize"),
        hidden: !0, frame: "none"
      };
      systemDirectoriesCreated || (systemDirectoriesCreated = createSystemDirectories());
      chrome.app.window.create(h, g, function (g) {
        console.timeEnd("ARC Window Popup");
        console.time("ARC appWindow Init");
        c && c(g);
        appWindow = g;
        appWindow.contentWindow.arc = {
          launchArgs: a,
          appLaunchTime: d,
          backgroundPage: window,
          runtimeUpdatedWhileRunning: null,
          userEmail: b,
          systemDirectoriesReady: new PromiseBridge(systemDirectoriesCreated)
        };
        appWindow.setBounds({width: k, height: l});
        appWindow.contentWindow.openParentWindow =
          function (a) {
            return window.open(a)
          };
        appWindow.onClosed.addListener(function () {
          appWindow = null;
          appLaunched = !1
        });
        console.timeEnd("ARC appWindow Init")
      })
    } else(h = appWindow.contentWindow.arc.onRelaunched) ? h(a) : console.error("onLaunched is called during initialization.")
  }

  appLaunched = !0;
  var d = arcMetadata.getValue("minimumLaunchDelay");
  0 < d ? (console.log("launchAppWindow delayed: " + d + " ms"), setTimeout(b, d)) : needEmailToLaunch_() ? PromiseWrap.getProfileUserInfo().then(function (a) {
    b(a.email)
  }, function (a) {
    console.error("Failed to get profile user info, continuing anyway: " +
    a.message);
    b()
  }) : b()
}
chrome.app.runtime.onLaunched.addListener(onLaunch);
function installLogic() {
  console.time("ARC onInstalled HTML5 FS init");
  var a = PromiseWrap.requestFileSystemRoot(PERSISTENT), a = applyPromise([a, "data", {create: !0}], PromiseWrap.getDirectory);
  applyPromise([a, "dalvik-cache", {create: !0}], PromiseWrap.getDirectory).then(function () {
    console.timeEnd("ARC onInstalled HTML5 FS init");
    addDexoptPlugin_()
  });
  systemDirectoriesCreated || (systemDirectoriesCreated = createSystemDirectories())
}
chrome.alarms.onAlarm.addListener(function (a) {
  "onInstallUpdate" == a.name && (appLaunched || installLogic())
});
chrome.runtime.onInstalled.addListener(function (a) {
  "install" == a.reason ? installLogic() : ("shared_module_update" == a.reason && appWindow && (appWindow.contentWindow.arc.runtimeUpdatedWhileRunning = new Date), a = Math.floor(Math.random() * _ONINSTALL_MAX_DELAY_IN_MINUTES) + 1, console.log("Delaying update install logic for " + a + " minutes"), chrome.alarms.create("onInstallUpdate", {delayInMinutes: a}))
});
function handleClipboardMessageBg_(a, c) {
  if ("jsClipboard" != a.namespace || "pushhost" != a.command && "pullhost" != a.command)return !1;
  var b = null, d = document.createElement("div");
  d.id = "clipboardHelperDiv";
  d.setAttribute("contentEditable", !0);
  d.width = d.height = 0;
  d.style.position = "absolute";
  var e = document.body, f = document.activeElement;
  e.appendChild(d);
  d.focus();
  "pushhost" == a.command ? (d.innerHTML = "" != a.data.value ? a.data.value : "\x00", b = document.execCommand("selectAll") && document.execCommand("cut")) : "pullhost" == a.command &&
  document.execCommand("paste") && (b = d.innerHTML, "\x00" == b && (b = ""));
  c({namespace: "androidClipboard", command: a.command + "response", data: {result: b}});
  e.removeChild(d);
  f && f.focus();
  return !0
}
function handleSystemMessageBg_(a) {
  return "jsSystem" == a.namespace && "relaunchApp" == a.command ? (onLaunch({forceWindowCreate: !0}), !0) : !1
}
function handleUmaMessageBg_(a) {
  return "jsUma" == a.namespace && "scheduleUma" == a.command ? (scheduleUma(a.data.uma_data, a.data.immediate), !0) : !1
}
chrome.runtime.onMessage.addListener(function (a, c, b) {
  handleClipboardMessageBg_(a, b) || handleSystemMessageBg_(a) || handleUmaMessageBg_(a) || (console.error("Unhandled message: "), console.error(a))
});
chrome.runtime.onSuspend.addListener(function () {
  reportUma()
});
function scheduleUma(a, c) {
  c = !!c;
  pendingUma = pendingUma.concat(a);
  c ? reportUma() : setTimeout(reportUma, 2E4)
}
function reportUma() {
  if (0 != pendingUma.length && !arcMetadata.getValue("isSlowDebugRun")) {
    var a = {
      requestId: 0,
      requester: "backgroundpage",
      plugin: "so_executable",
      args: ["umareporter"].concat(pendingUma)
    };
    new ChildPlugin(document.getElementById("childplugindiv"), a, function (a) {
    }, null, null);
    pendingUma = []
  }
};
//# sourceMappingURL=gen_main.min.js.map
